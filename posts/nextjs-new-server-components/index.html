<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'none'; object-src 'none'; style-src 'self' 'unsafe-inline';"><title>NextJs and New Server Components</title><meta property="og:title" content="NextJs and New Server Components"><meta name="description" content="This article outlines the benefits, rules and limitations of newly added Next.JS server components"><meta property="og:description" content="This article outlines the benefits, rules and limitations of newly added Next.JS server components"><meta name="keywords" content="nextjs, next, server components, server-components, react, reactjs, performance, next13.4"><link rel="canonical" href="https://drag13.io/posts/nextjs-new-server-components/index.html"><meta property="og:url" content="https://drag13.io/posts/nextjs-new-server-components/index.html"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="https://twitter.com/drag137"><meta name="twitter:url" content="https://drag13.io/posts/nextjs-new-server-components/index.html"><meta name="twitter:title" content="NextJs and New Server Components"><meta name="twitter:description" content="This article outlines the benefits, rules and limitations of newly added Next.JS server components"><meta name="og:site_name" content="Drag13 Dev Blog"><meta name="application-name" content="Drag13 programmer's blog"><meta name="author" content="Drag13"><meta name="robots" content="index follow"><meta name="application-name" content="Drag13 Dev Blog"><link rel="stylesheet" href="https://drag13.io/common.fa446fe9.css"><style>.post .tag{color:var(--hashtag)}</style><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://drag13.io/apple-touch-icon-144x144.f6d9dce4.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://drag13.io/apple-touch-icon-152x152.5c0b4e01.png"><link rel="icon" type="image/png" href="https://drag13.io/favicon-32x32.2ff4c37a.png" sizes="32x32"><link rel="icon" type="image/png" href="https://drag13.io/favicon-16x16.60caff07.png" sizes="16x16"><link rel="manifest" crossorigin="use-credentials" href="https://drag13.io/manifest.webmanifest"><body><nav class="nav"><a class="link" href="/" title="Back to the main page">Home</a><div><a class="icon" href="https://github.com/Drag13" target="_blank" rel="noopener" title="Drag13 GitHub profile"><svg height="32" viewBox="0 0 16 16" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><a class="icon" href="https://twitter.com/drag137" target="_blank" rel="noopener" title="Drag13 Twitter profile"><svg height="32" width="32" viewBox="0 0 24 24" aria-hidden="true" fill="rgba(29,161,242,1.00)"><path d="M23.643 4.937c-.835.37-1.732.62-2.675.733a4.67 4.67 0 002.048-2.578 9.3 9.3 0 01-2.958 1.13 4.66 4.66 0 00-7.938 4.25 13.229 13.229 0 01-9.602-4.868c-.4.69-.63 1.49-.63 2.342A4.66 4.66 0 003.96 9.824a4.647 4.647 0 01-2.11-.583v.06a4.66 4.66 0 003.737 4.568 4.692 4.692 0 01-2.104.08 4.661 4.661 0 004.352 3.234 9.348 9.348 0 01-5.786 1.995 9.5 9.5 0 01-1.112-.065 13.175 13.175 0 007.14 2.093c8.57 0 13.255-7.098 13.255-13.254 0-.2-.005-.402-.014-.602a9.47 9.47 0 002.323-2.41z"/></svg></a></div></nav><main class="main"><div class="content markdown-body"><article class="post"><h1>NextJs and new Server Components - How to use and limitations</h1>
<p>Hello everyone, recently I have spent a lot of time dealing with the new feature in <a href="https://nextjs.org/">Next.JS</a> - server components, and now I want to share my experience and some thoughts about this update, including the benefits, limitations, and how to use them in real-life scenarios.</p>
<p>If you are interested in Next.JS or web performance in general, grab a cup of coffee and let's start reading!</p>
<h2>Why were server components introduced?</h2>
<p>Let's start with the most important question - <strong>"Why were server components introduced?"</strong></p>
<p>As you probably already know, Next.JS works as follows (simplified):</p>
<ul>
<li>The client requests the address served by the Next.JS server.</li>
<li>Next.JS, at runtime (optimizations with caching may occur), receives the necessary data to create the page.</li>
<li>Then, it creates an HTML page that is sent to the client, along with the javascript code. Since the page is just plain HTML, the user sees it as it loads and, unlike SPA, doesn't have to wait for React to create it from scratch on the client-side.</li>
<li>After receiving the client bundle, the hydration process takes place - transforming static HTML into the familiar React application that the user can interact with. If hydration is not performed, the user won't be able to interact with the HTML page because all event listeners are added at this stage</li>
</ul>
<p>Schematically this looks something like this:</p>
<p><img src="https://drag13.io/default-schema.67e6f2f1.png" alt="./default-schema.png"></p>
<p>The reason for all this non-trivial process is to ensure that your users see the content they need as quickly as possible and doesn't leave your website frustrated. It also simplifies the life of SEO robots and increases the chances of your page ranking higher in search results. Meanwhile, the developer can work in the familiar and convenient React with all its advantages - a component approach, HMR, and a rich toolkit.</p>
<p>Unfortunately this process has drawbacks, the biggest of which is that it takes time to hydrate, during which the application is non-interactive. The larger your bundle, the more time it takes to hydrate. There is even a possibility that the user has already loaded the page, tries to interact with it, but it doesn't respond because the main thread is busy. This leaves the impression that the page doesn't work at all, and people may just leave and tell their friends that your store doesn't work.</p>
<p>The second drawback is that, as in hydration and the React application lifecycle, all components participate, even those whose content never changes. This, accordingly, reduces the response time of your page to user actions, which is bad for the user experience.</p>
<p>And here come the server components to the rescue, which try to solve both problems at once by:</p>
<ul>
<li>
<p><strong>Dependencies used in server components are not included in the bundle at all</strong>. This reduces its size and speeds up the moment when your page becomes interactive.</p>
</li>
<li>
<p><strong>Server components do not participate in either hydration or the application lifecycle</strong>, which speeds up the application's response time (giving more time for other operations) and saves your phone's battery.</p>
</li>
</ul>
<p>Of course, such magic is not free, so server components have significant limitations (some of which almost completely negate their usefulness, at least for now).</p>
<h2>Rules and limitations of server components</h2>
<p><strong>The first rule of server components</strong> is that server components cannot have added behavior such as useState, useEffect, onClick, and other interactive features. This is logical since server components cannot be changed on the client-side. If you still need some behavior, you need client components. Regular functions, including fetch, are allowed. But keep in mind that server components run on the server, so they cannot access the browser API, window, and document objects. Another interesting point is that native interactivity of elements has not disappeared, so forms, checkboxes, radio buttons, links, summary, and all other components with built-in behavior will work fine.</p>
<p>Also, server components cannot use context, which means that many familiar tools built on context - such as Redux Toolkit, Emotion, and even the popular MUI component library - do not work with server components. And this, in my opinion, is the biggest and most significant drawback of server components, which almost negates all their benefits. However, there is an experimental server context, but it is not yet used by third-party libraries and does not work correctly during navigation.</p>
<p><strong>The second rule of server components</strong> is that all components are considered server components until otherwise stated. If you need a client component, you must add the 'use client' directive at the beginning of the file with the components, before all imports.</p>
<p><strong>The third rule of server components</strong> is that importing a server component to the client automatically transforms it into a client component, thereby depriving it of all the advantages I mentioned above. This moment is very important, so I emphasize it again: any server components imported into a client component are automatically converted into client components. This effect is transitive - sub-components also become client components automatically, and so on until the last component in the hierarchy.</p>
<p>The practical consequence of this is that if you add the <code>"use-client"</code> directive to your root component (such as a page), all its imports and the imports of their imports will automatically be converted to client components, which will still be rendered on the server-side but lose the benefits of server components, such as reduced bundle size and avoiding re-rendering; therefore, the <code>"use-client"</code> directive should be used as low in the import hierarchy as possible, or alternatively, you can use children in client components, as long as the composing component is a server component because there is no direct import.</p>
<p><strong>Finally, the fourth rule of server components</strong> is that they can be asynchronous and can receive data directly in the component body, without any useEffect. Then, this data can be processed and passed to the client components, which can create context and add some interaction. And for handling errors that occur during asynchronous operations, you can add an error.jsx/tsx file. This is quite convenient and slightly improves the impression of all previous limitations, but not much.</p>
<h2>Wrapping up</h2>
<p>In summary, the technology of server components has the potential to make your applications faster by reducing the bundle size. However, the inability to use context and libraries built on it almost completely negates their usefulness in the real world. Even if your page is completely static but uses a popular CSS in JS library like Emotion for styling, you cannot fully utilize server components - at best, you can use them as a container for convenient data retrieval, but obviously, this is not what developers had in mind when they added server components.</p>
<p>Thanks for the attention!</p>
<h2>UPDATE</h2>
<p><a href="https://github.com/mui/material-ui/releases/tag/v5.14.0">Material UI</a> version 5.14.0 has announced support for the new app router in Next.js and updated their guides:</p>
<p><img src="https://drag13.io/mui.bf492d5b.png" alt="./mui.png"></p>
<p>Hopefully, we will see some progress with other tools soon</p>
<p class="tag">[14.08.2023] #nextjs #next #react #servercomponents #performance</p></article></div></main><footer class="footer"><a href="https://github.com/Drag13/drag13.github.io/blob/development/LICENSE" rel="noopener" target="_blank" title="License">2023 MIT by Drag13</a></footer></body></html>