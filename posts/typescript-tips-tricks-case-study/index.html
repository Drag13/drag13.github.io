<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'none'; object-src 'none'; style-src 'self' 'unsafe-inline';"><title>Advanced TypeScript - Tips and Tricks</title><meta property="og:title" content="Advanced TypeScript - Tips and Tricks"><meta name="description" content="It would seem that in 2022 it is a bit too late to talk about TypeScript - the technology is well known and popular. Despite this, some times TypeScript still used half-heartedly. Simple type annotations, null checking and nothing more. Therefore, I brought some interesting, purely practical cases to show mighty TypeScript in action!"><meta property="og:description" content="It would seem that in 2022 it is a bit too late to talk about TypeScript - the technology is well known and popular. Despite this, some times TypeScript still used half-heartedly. Simple type annotations, null checking and nothing more. Therefore, I brought some interesting, purely practical cases to show mighty TypeScript in action!"><meta name="keywords" content="typescript, typescript-tricks, typescript-advanced"><link rel="canonical" href="https://drag13.io/posts/typescript-tips-tricks-case-study/index.html"><meta property="og:url" content="https://drag13.io/posts/typescript-tips-tricks-case-study/index.html"><meta property="og:type" content="website"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="https://twitter.com/drag137"><meta name="twitter:url" content="https://drag13.io/posts/typescript-tips-tricks-case-study/index.html"><meta name="twitter:title" content="Advanced TypeScript - Tips and Tricks"><meta name="twitter:description" content="It would seem that in 2022 it is a bit too late to talk about TypeScript - the technology is well known and popular. Despite this, some times TypeScript still used half-heartedly. Simple type annotations, null checking and nothing more. Therefore, I brought some interesting, purely practical cases to show mighty TypeScript in action!"><meta name="og:site_name" content="Drag13 Dev Blog"><meta name="application-name" content="Drag13 programmer's blog"><meta name="author" content="Drag13"><meta name="robots" content="index follow"><meta name="application-name" content="Drag13 Dev Blog"><link rel="stylesheet" href="https://drag13.io/common.fa446fe9.css"><style>.post .tag{color:var(--hashtag)}</style><link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://drag13.io/apple-touch-icon-144x144.f6d9dce4.png"><link rel="apple-touch-icon-precomposed" sizes="152x152" href="https://drag13.io/apple-touch-icon-152x152.5c0b4e01.png"><link rel="icon" type="image/png" href="https://drag13.io/favicon-32x32.2ff4c37a.png" sizes="32x32"><link rel="icon" type="image/png" href="https://drag13.io/favicon-16x16.60caff07.png" sizes="16x16"><link rel="manifest" crossorigin="use-credentials" href="https://drag13.io/manifest.webmanifest"><body><nav class="nav"><a class="link" href="/" title="Back to the main page">Home</a><div><a class="icon" href="https://github.com/Drag13" target="_blank" rel="noopener" title="Drag13 GitHub profile"><svg height="32" viewBox="0 0 16 16" width="32" aria-hidden="true"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/></svg></a><a class="icon" href="https://twitter.com/drag137" target="_blank" rel="noopener" title="Drag13 Twitter profile"><svg height="32" width="32" viewBox="0 0 24 24" aria-hidden="true" fill="rgba(29,161,242,1.00)"><path d="M23.643 4.937c-.835.37-1.732.62-2.675.733a4.67 4.67 0 002.048-2.578 9.3 9.3 0 01-2.958 1.13 4.66 4.66 0 00-7.938 4.25 13.229 13.229 0 01-9.602-4.868c-.4.69-.63 1.49-.63 2.342A4.66 4.66 0 003.96 9.824a4.647 4.647 0 01-2.11-.583v.06a4.66 4.66 0 003.737 4.568 4.692 4.692 0 01-2.104.08 4.661 4.661 0 004.352 3.234 9.348 9.348 0 01-5.786 1.995 9.5 9.5 0 01-1.112-.065 13.175 13.175 0 007.14 2.093c8.57 0 13.255-7.098 13.255-13.254 0-.2-.005-.402-.014-.602a9.47 9.47 0 002.323-2.41z"/></svg></a></div></nav><main class="main"><div class="content markdown-body"><article class="post"><h1>Advanced TypeScript - Tips and Tricks</h1>
<p>It would seem that in 2022 it is a bit too late to talk about TypeScript - the technology is well known and popular. Despite this, some times TypeScript still used half-heartedly. Simple type annotations, null checking and nothing more. Therefore, I brought some interesting, purely practical cases to show mighty TypeScript in action!</p>
<h2>Narrowing primitives</h2>
<p>Let's start simple. Imagine that we have a function that takes a key as input, extracts a translation from the dictionary by the key and returns it. What will be the type of this key? Most likely - string. But it is clear that not everyone string is a valid key - we certainly do not need the entire British Encyclopedia right? And of course we don't want to have typos.</p>
<p>This problem can be solved in different ways. For example, if the translation does not exist, you can throw an exception (users will be very happy to get run time exception, right?). The second option is to return the same key, and pledge the fact that the key does not exist, so that later you can find out what went wrong. In any case, we will find out that the problem has occurred somewhere later, but we would like to know in advance.</p>
<p>And here TypeScript has a very elegant solution - if you don't need the whole string, then be honest about it and just declare a subset:</p>
<pre><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">TranslationKey</span> <span class="token operator">=</span> <span class="token string">'grey'</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">translate</span><span class="token punctuation">(</span>key<span class="token operator">:</span> TranslationKey<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
</code></pre>
<p>Thanks to this technique, we get several advantages at once:</p>
<ul>
<li>We are protected from typos and keys that we are not yet ready for at the build stage.</li>
<li>When some key changes <code>( grey-&gt; gray)</code>, we will immediately see all the places where we need to update the code.</li>
<li>IntelliSense works - using the keys has become much easier, you don’t have to climb and look for how this one is spelled every time <code>landing_big_ad_imageblock_subheder</code> (by the way, did you notice a typo?)</li>
</ul>
<p>The same trick can be used if we want to validate a value before using it:</p>
<pre><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">Email</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">sendEmail</span> <span class="token operator">=</span> <span class="token punctuation">(</span>email<span class="token operator">:</span> Email<span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token function">sendEmail</span><span class="token punctuation">(</span><span class="token string">'fake@email'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fails</span>
</code></pre>
<p>When we try to pass <code>sendEmail</code> any string to the method, TS will force us to check this string before, for example, by writing a <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards">guard</a>:</p>
<pre><code class="language-typescript"><span class="token comment">// don't use in production please</span>
<span class="token keyword">const</span> isValidEmail <span class="token operator">=</span> <span class="token punctuation">(</span>maybeEmail<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> maybeEmail <span class="token keyword">is</span> Email <span class="token operator">=&gt;</span>
  <span class="token keyword">typeof</span> maybeEmail <span class="token operator">===</span> <span class="token string">"string"</span> <span class="token operator">&amp;&amp;</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\S+@\S+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>maybeEmail<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>If you are interested in the details of how it works, here is a link to the <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html">documentation</a>.</p>
<h2>Derived from types</h2>
<p>We figured out the primitives, now I want to show another feature that I often use - creating a new type based on an existing one. In OOP, we usually use inheritance, but TypeScript allows you to transform one type into another. Surely you have already used the type <code>Partial&lt;T&gt;</code> or <code>Required&lt;T&gt;</code> ,which come straight out of the box. But in addition to built-in types, we can create our own, for example, like this:</p>
<pre><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Dto<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">UserDto</span> <span class="token operator">=</span> Dto<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre>
<p>First, I described the domain model with which I am ready to work. For this example, I created a type User with a single field name that must contain a string. But since I don't want to relay on the third party service that the data comes from, I want to validate the response from the server. To do this, I created a derived type <code>UserDto</code> in which I am stating that I had no idea what they would send us. Now I, as well as everyone who comes after, will be forced to check the data before using it.</p>
<p>Naturally, using this approach, you can also write a validator schema.</p>
<p>Step 1. Let's create a generic type that contains all the same fields as the future type T, and the values ​​will be functions that take an argument of an unknown type and return a sign that the argument belongs to the given type.</p>
<pre><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">DtoValidator<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token keyword">is</span> <span class="token constant">T</span><span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>Step 2. Now we can write a validator in the form of a guard, in which we check the passed argument. If it satisfies the given conditions, we recognize that it belongs to the type NotEmptyString.</p>
<pre><code class="language-typescript"><span class="token keyword">const</span> isNotEmptyString <span class="token operator">=</span> <span class="token punctuation">(</span>v<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> v <span class="token keyword">is</span> NotEmptyString <span class="token operator">=&gt;</span>
  <span class="token keyword">typeof</span> v <span class="token operator">===</span> <span class="token string">"string"</span> <span class="token operator">&amp;&amp;</span> v<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre>
<p>Step 3. Finally let's put it all together into a validation scheme. Please note that now TS will ensure that all fields in the scheme are described and correctly filled out. If we miss something, TypeScript will throw an error.</p>
<pre><code class="language-typescript"><span class="token keyword">const</span> userValidator<span class="token operator">:</span> DtoValidator<span class="token operator">&lt;</span>User<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> isNotEmptyString<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>The great thing here is that when we extend the domain model with a new field, TS will automatically remind us that this field is also needed to check.</p>
<p>On my project, we use this approach for form validation. There is a form model, and a validator model is built on its basis. When form fields change (which happens periodically), TypeScript tells us where we went wrong.</p>
<h2>Dynamic modification of types</h2>
<p>This trick might be especially relevant if you're using contexts in React, but the idea will work everywhere. TS allows you to infer new types on the fly based on the data you pass in. This may sound a little confusing, so let's look at an example.</p>
<p>Let's write a function that greets the user:</p>
<pre><code class="language-typescript"><span class="token keyword">type</span> <span class="token class-name">User</span> <span class="token operator">=</span> <span class="token punctuation">{</span> firstName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Greetings</span> <span class="token operator">=</span> <span class="token punctuation">{</span> greetingText<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">getGreetings</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> firstName<span class="token punctuation">,</span> greetingText <span class="token punctuation">}</span><span class="token operator">:</span> User <span class="token operator">&amp;</span> Greetings<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>greetingText<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre>
<p>Obviously, the username will appear in runtime, but the text of the greeting itself can be static. You can write a higher order function that will inject <code>greetingText</code> into <code>getGreetings</code>.</p>
<pre><code class="language-typescript"><span class="token keyword">const</span> <span class="token function-variable function">greeterFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>user<span class="token operator">:</span> User<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token function">getGreetings</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>user<span class="token punctuation">,</span> greetingText<span class="token operator">:</span> <span class="token string">"Hello"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> greeter <span class="token operator">=</span> <span class="token function">greeterFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">greeter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> firstName<span class="token operator">:</span> <span class="token string">"Vitalii"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Everything is fine, but this solution is not generic and I want to have a general one that would:</p>
<ul>
<li>Worked with arbitrary types.</li>
<li>Removed from the required type those fields that are already contained in the embedded object.</li>
</ul>
<p>A naive implementation might look like this:</p>
<pre><code class="language-typescript"><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">factory</span><span class="token generic class-name"><span class="token operator">&lt;</span>TModel<span class="token punctuation">,</span> TResult<span class="token punctuation">,</span> TInjected <span class="token keyword">extends</span> Partial<span class="token operator">&lt;</span>TModel<span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span>
  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>m<span class="token operator">:</span> TModel<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> TResult<span class="token punctuation">,</span>
  inject<span class="token operator">:</span> TInjected
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>m<span class="token operator">:</span> Omit<span class="token operator">&lt;</span>TModel<span class="token punctuation">,</span> <span class="token keyword">keyof</span> TInjected<span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>inject<span class="token punctuation">,</span> <span class="token operator">...</span>m <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>However, it won't compile because I made a curious mistake:</p>
<pre><code class="language-typescript"><span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">(</span>m<span class="token operator">:</span> <span class="token punctuation">{</span> greeting<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> m<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  greeting<span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">"Vitalii"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"Joker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Since the type of the embedded object completely overrides the required type, the resulting type can be anything, even a string. This is clearly not what we would like. And it's good that TypeScript was smart enough to catch it. Therefore, the code will have to be <a href="https://stackoverflow.com/questions/70154354/higher-order-function-how-to-deduct-injected-type-from-model-without-casting/70334649#70334649">rewritten</a>:</p>
<pre><code class="language-typescript"><span class="token comment">// I am not a monster</span>
<span class="token keyword">function</span> factory<span class="token operator">&lt;</span>
  TCallback <span class="token keyword">extends</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">,</span>
  TModel <span class="token keyword">extends</span> <span class="token class-name">Parameters<span class="token operator">&lt;</span>TCallback<span class="token operator">&gt;</span></span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  TInjected <span class="token keyword">extends</span> <span class="token class-name">Partial<span class="token operator">&lt;</span>TModel<span class="token operator">&gt;</span></span>
<span class="token operator">&gt;</span><span class="token punctuation">(</span>callback<span class="token operator">:</span> TCallback<span class="token punctuation">,</span> injected<span class="token operator">:</span> TInjected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token operator">&lt;</span>TProps <span class="token keyword">extends</span> <span class="token class-name">Omit<span class="token operator">&lt;</span>TModel<span class="token punctuation">,</span> <span class="token keyword">keyof</span> TInjected<span class="token operator">&gt;</span></span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
    props<span class="token operator">:</span> TProps <span class="token keyword">extends</span> <span class="token class-name">object</span> <span class="token operator">?</span> TProps <span class="token operator">:</span> <span class="token builtin">never</span>
  <span class="token punctuation">)</span><span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span>TCallback<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token operator">...</span>injected<span class="token punctuation">,</span> <span class="token operator">...</span>props <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">greeter</span> <span class="token operator">=</span> <span class="token punctuation">(</span>_<span class="token operator">:</span> <span class="token punctuation">{</span> greeting<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">""</span><span class="token punctuation">;</span>

<span class="token comment">// "Argument of type 'string' is not assignable to parameter of type 'never'"</span>
<span class="token keyword">const</span> failed <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>greeter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  greeting<span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
  name<span class="token operator">:</span> <span class="token string">"Vitalii"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">"Joker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// // Works with full IntelliSense support.</span>
<span class="token keyword">const</span> working <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>greeter<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  greeting<span class="token operator">:</span> <span class="token string">"hello"</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">"test"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>Now everything works as expected, apart from a t-i-i-iny moment. First, it's hard to read, although the idea here is pretty simple and revolves around TypeScript's ability to extract types from functions and the Omit utility type. And secondly, in runtime, both in injected, and in props, an object with a much larger number of fields can get in, and this should be borne in mind.</p>
<p>For us, this approach came in handy when we wrote our connectors to the data store in React. As a result, only those fields that were not in the store had to be passed to the component, it would “take” the rest itself, and TypeScript would check that we had not forgotten to forward the missing ones. Since all objects are under our control, the nuance I mentioned was not a problem.</p>
<h2>Summary</h2>
<p>As you can see, TypeScript is more than just type annotation. It allows you to create subsets, projections, type inference on the fly, and much more that I didn't mention. Although there is no TypeScript at runtime, well-written types make development easier and can prevent misses.</p>
<p>On the other hand, seemingly obvious TypeScript solutions don't work. Mistakes are incomprehensible and not obvious, especially at the beginning of working with the language (and, to be honest, later too). The start of the project is also slower, since you need to design and describe types, and then also fix where you missed.</p>
<p>Still, the convenience that TypeScript provides is well worth it. Introducing new people to the project and even returning to a module that you have not worked with for at least a month is much easier and more enjoyable. The main thing is to maintain balance, as the main character of one very philosophical game said. If you see that TS complicates the support of your code, then someone has taken a wrong turn.</p>
<p class="tag">[03.05.2022] typescript typescript-tricks</p></article></div></main><footer class="footer"><a href="https://github.com/Drag13/drag13.github.io/blob/development/LICENSE" rel="noopener" target="_blank" title="License">2023 MIT by Drag13</a></footer></body></html>